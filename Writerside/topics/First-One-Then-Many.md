# First One, Then Many
akka "One to Many"

[First One, Then Many - by Kent Beck](https://tidyfirst.substack.com/p/first-one-then-many)

> 사람들은 "하지만 작고 안전한 조치로는 큰 변화를 만들 수 없어요."라고  말하곤 한다

- 저는 항상, **항상 할 수 있습**니다.
    - 때로는 **지금 당장 방법을 정확히 생각할 수 없을 때도 있습**니다
    - 그런 다음 **더 큰 발걸음을 내딛고 실패하면 방법을 찾아내죠**.
    - 항상 작은 발걸음을 내딛을 필요는 없지만, 작은 발걸음은 언제나 선택 사항입니다.
- 시스템은 **결국 임의의 수의 요소를 처리해야 하지만** **지금은 하나만 처리하면 됩**니다. 어떻게 해야 할까요?

## Introduction
- 매년 하나의 트랜잭션이 게시되는 시스템을 구축한다고 가정
    - 시스템이 두 개 이상의 트랜잭션을 처리해야 하는 시점은 지금부터 1년 후
    - 그 사이 1년 동안 구현과 API는 어떻게 되어야 할까요?
- 최종 결과가 명확하고 리팩터링이 필요 없기 때문에 도약 전략(Leap Strategy)[도약은 한 단계로 한 디자인에서 다른 디자인으로 이동]을 적용하고 싶은 유혹을 느낄 수 있습니다

```java
// Contract
List<Transaction> transactions;
Iterator<Transaction> getTransactions();
```

## Half and Half

- 고객에게 계약에 두 개 이상의 거래가 있을 때 보고서가 어떻게 구성되어야 하는지 물어봤는데 고객이 알려주지 못한다고 가정해 보겠습니다
    - 너무 바쁘거나, 잘 모르거나, 결정하기 전에 시스템에 대한 경험을 좀 더 해보고 싶어서일 수 있습니다.
- 한 가지 전략은 다중 트랜잭션 구현 및 API로 도약하되 고객이 단일 트랜잭션이 있다고 가정하도록 하는 것입니다:
```java
// ContractReport
Transaction first= contract.getTransactions().next();
format(first);
```

- 그렇게 함으로써 우리는 함정을 남겼습니다
    - 1년 후 두 번째 거래가 게시되면 보고서에는 현재 보유하고 있는 정보가 더 이상 반영되지 않을 것입니다
    - 계약 보고서는 완료될 때까지 실행되지만 대답은 조용히 오해의 소지가 있을 것입니다.
- 문제는 클라이언트 코드가 계약 API와 미묘하게 다른 가정을 가지고 있다는 것임
    - 즉
        - 1) 명시적이지 않고,
        - 2) 컴파일러로 확인할 수 없으며,
        - 3) 순간의 열기에 쉽게 만들 수 있는
    - 가정을 가지고 있다는 것입니다
    - 단 하나의 트랜잭션에서만 작동하더라도 보고서를 완성하세요!!!
- 클라이언트 코드에 반창고를 붙여 단일 트랜잭션이 있다는 가정을 명시적으로 확인할 수 있습니다:
```java
// ContractReport
Iterator<Transaction> all= contract.getTransactions();
Transaction first= all.next();
if (all.hasNext())
  throw new Error("We can't yet report on contracts with more than one transaction");
format(first);
```
- 가드 절은 코드가 자동으로 오답을 생성하는 것을 방지하지만
    - 1) 단일 트랜잭션 가정을 하는 모든 곳에 가드를 추가할 만큼 현명하고 신중해야 하며
    - 2) 가드는 트리거될 때까지 피드백을 제공하지 않습니다. 피드백을 더 일찍 받는 것이 유용할 것입니다.
- 우리는 미래에 어떤 일이 일어날지 알고 있고, 그에 대비해 프로그래밍하고 있으며, 무엇이 잘못될 수 있을까요?

## Succession
퍼머컬처의 설계 원칙인 계승(succession)은 대안적인 해결책을 제시
농업에서 계승이란 **시간이 지남에 따라 의도적으로 변화하는 설계**를 말합
**빠르게 자라는 만자니타를 심어 토양을 안정**시키고 **더 느리게 자라는(그리고 더 가치 있는)** 더글러스 전나무가 자라는 동안 더글러스 전나무를 심는 것
**최종 목표는 키 큰 전나무 숲**이지만, 다른 것을 먼저 심는 것이 더 에너지 효율적인 방법일 수 있습니다.

```java
Contract
Transaction transaction;
Transaction getTransaction();
```

이 설계는 현재 우리의 현실을 반영합니다: 우리는 하나의 거래를 하고 있습니다.
승계 기반 설계의 장점은 계약의 가정과 고객의 가정이 항상 일치한다는 조화입니다. 모든 사람에게 거래는 단 하나뿐입니다:

```java
ContractReport
Transaction first= contract.getTransaction();
format(first);
```

## And Then...

**두 번째 거래를 게시할 때가 되면 승계에 대한 대가**를 지불합니다.
이 날짜 이전에 적절하게 계약과 모든 클라이언트를 업그레이드해야 하지만(고객은 다중 거래 보고서의 모양을 알려줄 준비가 되어 있어야 함), 계약과 클라이언트를 모두 한 단위로 변경합니다.
API와 클라이언트의 가정은 항상 동기화됩니다.

위험을 줄이고 승계의 효율성을 높이기 위해 공통적인 승계에 대한 템플릿을 머릿속에 가지고 있습니다(일관되고 포괄적인 카탈로그를 시작하기에 충분한 승계가 있을 수 있지만 이는 반응형 디자인의 미래를 위한 주제입니다)
(명확하게 생각할 때는 나만의 템플릿을 사용하기도 합니다.)
일대다 승계는 다음과 같이 작동합니다:

1. 트랜잭션이 여러 개 있는 것처럼 보이도록 API를 추가:
```java
// Contract
Iterator<Transaction> getTransactions() {
    return (new Transaction[] {transaction}).iterator();
}
```
2. **병렬 구현 parallel implementation**을 추가하여 여러 트랜잭션을 병렬로 처리:
```java
// Contract
Transaction transaction;
List<Transaction> transactions;
```
3. 이전 트랜잭션이 설정된 모든 곳에서 트랜잭션 목록도 설정합니다
```java
transaction= ...;
transactions= Collections.singletonList(transaction);
```
- Now we are guaranteed that the list will always contain a single item, and that item will be identical to the contents of transaction, so we can...
4. 트랜잭션에 대한 모든 참조를 목록에 대한 동등한 참조로 바꿉:
```java
// Contract
Iterator<Transaction> getTransactions() {
    return transactions.iterator();
}
```

이 모든 '안전한 발걸음(safe stepping)'이 많은 작업처럼 보일 수 있습니다
제 경험에 따르면 연습을 하면 실수할 가능성을 최소화하면서 매우 빠르게 단계를 진행할 수 있습니다
결국 많은 템플릿이 자동화된 리팩터링으로 전환되어 훨씬 더 빠르고 안전해집니다
효율성이라는 명목으로 서둘러서 몇 단계를 건너뛰면 연속성이 느려지고 예측할 수 없게 됩니다.

바로 지난주에 이런 문제가 발생했습니다
저는 모든 파일 이름 사용을 스트림 사용으로 바꾸고 있었습니다(일반적으로 호출 트리에서 최대한 높은 위치에서 스트림으로 변환하고 나머지 코드를 스트림으로 작성하는 것이 좋지만, 효율성이라는 명목으로 이를 무시하고 있었죠)
저는 제가 사용하는 템플릿과 상관없이 눈에 보이는 다음 변경 사항을 계속 진행했고 결국 반나절의 작업을 버려야 했습니다
우선순위가 명확할 때는 템플릿을 엄격하게 지키는 편이 더 큰 문제에 대해 생각할 시간을 가질 수 있습니다.

## Conclusion
- 다음은 이 백서의 주제와 다른 작업 간의 몇 가지 연관성입니다:
    - 일반적으로 승계는 린 소프트웨어 개발 원칙인 풀의 한 예입니다
        - 고객의 요구 사항에서 시작하여 그 요구 사항을 충족할 수 있는 충분한 시스템을 만듭니다
        - 이러한 요구를 충족시키는 우연한 해킹이 아니라, 이러한 요구를 충족시키는 일관되고 일관된 디자인으로 군더더기 없는 시스템을 만듭니다.
    - 특히 '먼저 하나, 그다음 다수(First One, Then Many)'라는 연속성 역시 반응형 디자인의 단순화 원칙을 보여주는 예입니다
        - 우리가 상상할 수 있는 디자인으로 바로 넘어갈 수 없었기 때문에 더 단순하지만 여전히 가치를 제공하는 디자인을 만들었습니다.
    - "먼저 하나, 그다음 다수"는 완성된 작업의 린 원칙을 보여주는 예입니다
        - 다중 트랜잭션 API를 설계하고 이를 단일 트랜잭션 방식으로 사용함으로써 시스템을 반쯤 완성된 상태로 남겨두었습니다
        - 작업을 자체적으로 일관된 단계로 나누면 전체 작업을 절반만 완료하는 대신 절반만 완료하고 나머지는 나중에 완료할 수 있습니다.
- "먼저 하나, 그다음 다수"는 하나에서 여러 개로 전환하는 데 드는 비용이 수반되며, 이 비용이 합리적이기 위해서는 반드시 보상이 따라야 합니다
    - 시스템이 여러 요소로 무엇을 해야 하는지 이미 알고 있다면 일반적으로 그냥 뛰어넘습니다
    - 제가 최고 수준에 도달하지 못했거나 함께 도약할 준비가 되지 않은 사람과 코딩하는 등 의도적으로 진행하는 경우에는 승계를 적용하는 것이 합리적입니다
    - 클라이언트가 여러 요소로 무엇을 해야 할지 모른다면 승계를 적용하는 것이 합리적입니다.
    - 여러 요소의 가능성이 불확실하거나 먼 미래의 일이라면 승계를 적용하는 것이 합리적일 수 있습니다
    - 승계에 따른 비용과 더 빨리 끝낼 때의 이점 및 일관되지 ↓않은 가정으로 인한 비용을 비교 검토해야 합니다
    - 요컨대, 저는 두 배에 각각 한 발씩 발을 딛고 서 있는 것보다 단단한 바닥에 서서 자신감 있게 한 걸음씩 나아가는 것이 더 낫다고 생각합니다.
